import uuid
from . import mysql_connectors
from models.models import CreateConversationRequest
from utils.loggers import mysql_error_logger
MySQLReadWriteConnector = mysql_connectors.MySQLReadWriteConnector()


'''
Creates a conversation
'''
async def create_conversation(request: CreateConversationRequest):
    try:
        new_uuid = str(uuid.uuid4())
        await MySQLReadWriteConnector.start_connection()
        cursor = await MySQLReadWriteConnector.connect.cursor()

        uuid_exists = True

        while uuid_exists:

            await cursor.execute(
                "SELECT COUNT(conversation_id) FROM conversations WHERE conversation_id = %s ORDER BY timestamp DESC",
                (new_uuid,)
            )

            rows = await cursor.fetchall()

            # If the UUID is not used, loop is broken. Otherwise, a new UUID is generated and checked.
            if rows[0][0] == 0:
                uuid_exists = False
            else:
                new_uuid = str(uuid.uuid4())

        result = await cursor.execute(
            "INSERT INTO conversations (conversation_id, title, user_mail) VALUES (%s, %s, %s)",
            (new_uuid, request.title, request.user_mail)
        )

        await MySQLReadWriteConnector.connect.commit()

        if result > 0:
            return new_uuid
        else:
            return None

    except Exception as e:
        print(f"Error inserting conversation: {e}")
        return None

    finally:
        try:
            await MySQLReadWriteConnector.close_connection()
        except Exception as close_err:
            raise RuntimeError(f"Failed to close DB connection: {close_err}") from close_err

'''
Obtains all messages assigned to a conversation
'''
async def get_conversation(conversation_id: str):
    pass

'''
Obtains all the conversation IDs assigned to that user
'''
async def get_user_conversations(user_email: str):
    try:
        await MySQLReadWriteConnector.start_connection()
        cursor = await MySQLReadWriteConnector.connect.cursor()

        await cursor.execute(
            "SELECT conversation_id, title FROM conversations WHERE user_mail = %s ORDER BY timestamp DESC",
            (user_email,)
        )
        conversations = await cursor.fetchall()

        await MySQLReadWriteConnector.connect.commit()

        if conversations is None:
            return None
        else:
            return conversations

    except Exception as e:
        raise RuntimeError(f"Failed to fetch all conversations ID for user: {e}") from e

    finally:
        try:
            await MySQLReadWriteConnector.close_connection()
        except Exception as close_err:
            raise RuntimeError(f"Failed to close DB connection: {close_err}") from close_err


'''
Adds generated by user/assistant messages assigned to a conversations
'''
async def add_message_conversation(conversation_id: str):
    pass

'''Creates model register indicating model name, origin, is_available etc'''
async def create_model(model_id: str, user_id: str, model_name: str):
    pass

async def get_available_models_list():
    try:
        await MySQLReadWriteConnector.start_connection()
        cursor = await MySQLReadWriteConnector.connect.cursor()
        result = await cursor.execute("SELECT name FROM models WHERE is_available = %s", ('Y',))
        await MySQLReadWriteConnector.connect.commit()
        if result == 0:
            return []
        else:
            return [row[0] for row in result]

    except Exception as e:
        # Log it, handle it, or re-raise
        raise RuntimeError(f"Failed to fetch available models: {e}") from e
    finally:
            try:
                await MySQLReadWriteConnector.close_connection()
            except Exception as close_err:
                # Handle closing errors separately if needed
                raise RuntimeError(f"Failed to close DB connection: {close_err}") from close_err
